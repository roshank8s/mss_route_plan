// File: address_multiple_markers_gmap.js
import { Component, useRef, onWillStart, onMounted } from "@odoo/owl";
import { registry } from "@web/core/registry";
import { _t } from "@web/core/l10n/translation";
import { useService } from "@web/core/utils/hooks";
import { loadJS } from "@web/core/assets";
export class AddressMultipleMarkersGmap extends Component {
    static template = "web.AddressMultipleMarkersGmap";
    static props = {};

    setup() {
        this.orm = useService("orm");
        this.notification = useService("notification");
        this._gmapApiKey = false;
        this.mapref = useRef("googleMap");
        this.recordList = useRef("recordList");

        // track offsets for overlapping markers
        const markerPositions = {};

        // simple marker factory with InfoWindow
        let _lastHue = Math.random() * 360;
        const addMarker = (position, displayName, address, label = null, icon = null) => {
            const key = `${position.lat.toFixed(6)},${position.lng.toFixed(6)}`;
            if (markerPositions[key] === undefined) {
                markerPositions[key] = 0;
            } else {
                markerPositions[key]++;
                const offset = markerPositions[key] * 0.0001;
                position = { lat: position.lat + offset, lng: position.lng + offset };
            }

            let html = `<div><strong>${displayName||""}</strong>`;
            if (address && address !== "false") {
                html += `<br/>${address}`;
            }
            html += `</div>`;

            const opts = { position, map: this.map, title: displayName, icon };
            if (label) {
                opts.label = {
                    text: label,
                    color: "white",
                    fontSize: "12px",
                    fontWeight: "bold",
                };
            }
            const m = new google.maps.Marker(opts);
            const iw = new google.maps.InfoWindow({ content: html });
            m.addListener("click", () => iw.open(this.map, m));
            m.infoWindow = iw;
            return m;
        };
        // function getRandomColor() {
        //     const ch = () => Math.floor(Math.random()*512).toString(16).padStart(2,"0");
        //     return `#${ch()}${ch()}${ch()}`;
        // }

        function getRandomColor() {
            _lastHue = (_lastHue + 137.508) % 360;
            // round to one decimal if you like, or drop to use full precision
            const hue = Math.round(_lastHue * 10) / 10;
            return `hsl(${hue}, 65%, 50%)`;
        }

        onWillStart(async () => {
            const key = await this._getGMapAPIKey();
            if (!key) {
                this.notification.add(
                    _t("Google Map API Key not configured. Please setup in Settings."),
                    { title: _t("API Key Missing"), type: "danger", sticky: true }
                );
            }
            const url = `https://maps.googleapis.com/maps/api/js?key=${key}&libraries=places,maps async`;
            await loadJS(url);
        });

        onMounted(async () => {
            // init map
            this.map = new google.maps.Map(this.mapref.el, {
                center: { lat: 0, lng: 0 },
                zoom: 2,
            });

            // custom icons
            const icons = {
                start: {
                    url: "/mss_route_plan/static/description/Start.png",
                    scaledSize: new google.maps.Size(50,50),
                },
                job: {
                    url: "/mss_route_plan/static/description/pinblue.png",
                    scaledSize: new google.maps.Size(50,50),
                },
                end: {
                    url: "/mss_route_plan/static/description/End.png",
                    scaledSize: new google.maps.Size(50,50),
                },
            };

            // clear sidebar
            this.recordList.el.innerHTML = "";

            try {
                // fetch all Traktop with vehicle_id
                const records = await this.orm.call("traktop", "search_read", [
                    [], [
                        "id",
                        "partner_latitude","partner_longitude",
                        "display_name","delivery_address",
                        "vehicle_name","vehicle_id",
                        "route_sequence","step_type",
                    ],
                ]);

                // group by vehicle_id
                const routes = {};
                for (const rec of records) {
                    // skip unassigned
                    if (!rec.vehicle_id || !rec.vehicle_id[0]) {
                        continue;
                    }
                    const vid = rec.vehicle_id[0];
                    if (!routes[vid]) {
                        routes[vid] = {
                            vehicleName: rec.vehicle_name || rec.vehicle_id[1],
                            records: [],
                        };
                    }
                    routes[vid].records.push(rec);
                }

                // for each vehicle
                for (const [vid, { vehicleName, records: recs }] of Object.entries(routes)) {
                    // sort by route_sequence
                    recs.sort((a,b) => a.route_sequence - b.route_sequence);

                    const startRec = recs.find(r => r.step_type === "start");
                    const endRec   = recs.find(r => r.step_type === "end");
                    const jobs     = recs.filter(r => r.step_type === "job");

                    // need at least start, end, and one job
                    if (!startRec || !endRec || !jobs.length) {
                        console.warn(`Vehicle ${vehicleName} has incomplete route, skipping`);
                        continue;
                    }

                    const bounds = new google.maps.LatLngBounds();
                    const color  = getRandomColor();

                    // sidebar header
                    const hdr = document.createElement("li");
                    hdr.textContent = vehicleName;
                    hdr.style.fontWeight = "bold";
                    hdr.style.color      = color;
                    hdr.style.cursor     = "pointer";
                    hdr.style.margin     = "10px 0 5px";
                    hdr.style.listStyle  = "none";

                    const arrow = document.createElement("span");
                    arrow.textContent = " ▼";
                    hdr.appendChild(arrow);

                    const detailUl = document.createElement("ul");
                    detailUl.style.listStyle    = "none";
                    detailUl.style.paddingLeft  = "15px";
                    detailUl.style.display      = "none";

                    hdr.addEventListener("click", () => {
                        const hidden = detailUl.style.display === "none";
                        detailUl.style.display = hidden ? "block" : "none";
                        arrow.textContent = hidden ? " ▲" : " ▼";
                        this.map.fitBounds(bounds);
                    });

                    this.recordList.el.appendChild(hdr);
                    this.recordList.el.appendChild(detailUl);

                    // place start marker
                    const sLat = parseFloat(startRec.partner_latitude);
                    const sLng = parseFloat(startRec.partner_longitude);
                    bounds.extend({ lat: sLat, lng: sLng });
                    addMarker(
                        { lat: sLat, lng: sLng },
                        `Start ${vehicleName}`,
                        startRec.delivery_address,
                        null,
                        icons.start
                    );

                    // place end marker
                    const eLat = parseFloat(endRec.partner_latitude);
                    const eLng = parseFloat(endRec.partner_longitude);
                    bounds.extend({ lat: eLat, lng: eLng });
                    addMarker(
                        { lat: eLat, lng: eLng },
                        `End ${vehicleName}`,
                        endRec.delivery_address,
                        null,
                        icons.end
                    );

                    // jobs
                    let count = 1;
                    for (const rec of jobs) {
                        const lat = parseFloat(rec.partner_latitude);
                        const lng = parseFloat(rec.partner_longitude);
                        bounds.extend({ lat, lng });
                        const marker = addMarker(
                            { lat, lng },
                            rec.display_name || _t("Job"),
                            rec.delivery_address,
                            String(count),
                            icons.job
                        );

                        const li = document.createElement("li");
                        li.style.cursor = "pointer";
                        li.style.marginBottom = "10px";
                        li.style.listStyle = "none";

                        const titleDiv = document.createElement("div");
                        titleDiv.textContent = rec.display_name;
                        titleDiv.style.fontWeight = "bold";
                        const addrDiv = document.createElement("div");
                        addrDiv.textContent = rec.delivery_address;
                        addrDiv.style.fontSize = "small";
                        addrDiv.style.color = "#666";

                        li.appendChild(titleDiv);
                        li.appendChild(addrDiv);
                        li.addEventListener("click", () => {
                            this.map.panTo({ lat, lng });
                            this.map.setZoom(12);
                            marker.infoWindow?.open(this.map, marker);
                        });
                        detailUl.appendChild(li);
                        count++;
                    }

                    // draw polyline via Directions API
                    const directionsService  = new google.maps.DirectionsService();
                    const directionsRenderer = new google.maps.DirectionsRenderer({
                        map: this.map,
                        suppressMarkers: true,
                        polylineOptions: { strokeColor: color, strokeOpacity: 0.8, strokeWeight: 4 },
                    });

                    const waypoints = jobs.map(r => ({
                        location: { lat: parseFloat(r.partner_latitude), lng: parseFloat(r.partner_longitude) },
                        stopover: true,
                    }));

                    directionsService.route({
                        origin:      { lat: sLat, lng: sLng },
                        destination: { lat: eLat, lng: eLng },
                        waypoints,
                        travelMode:  google.maps.TravelMode.DRIVING,
                    }, (res, st) => {
                        if (st === google.maps.DirectionsStatus.OK) {
                            directionsRenderer.setDirections(res);
                        } else {
                            console.error("Directions failed:", st);
                        }
                    });
                }

            } catch (err) {
                console.error("Error loading routes:", err);
                this.notification.add(_t("Failed to load route data."), { type: "danger" });
            }

            // --- live user locations (unchanged) ---
            let userLiveMarkers = {};
            const updateLive = async () => {
                try {
                    const parts = await this.orm.call("res.partner", "search_read", [
                        [], ["live_latitude","live_longitude","name","id"]
                    ]);
                    const liveIcon = {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: "skyblue",
                        fillOpacity: 1,
                        scale: 8,
                        strokeColor: "white",
                        strokeWeight: 2,
                    };
                    parts.filter(p => {
                        const la = parseFloat(p.live_latitude);
                        const lo = parseFloat(p.live_longitude);
                        return !isNaN(la) && !isNaN(lo) && la!==0 && lo!==0;
                    }).forEach(p => {
                        const pos = { lat: parseFloat(p.live_latitude), lng: parseFloat(p.live_longitude) };
                        if (userLiveMarkers[p.id]) {
                            userLiveMarkers[p.id].setPosition(pos);
                        } else {
                            userLiveMarkers[p.id] = addMarker(pos, p.name, "", null, liveIcon);
                        }
                    });
                } catch (e) {
                    console.error("Live update error:", e);
                }
            };
            updateLive();
            setInterval(updateLive, 5000);
        });
    }

    async _getGMapAPIKey() {
        if (!this._gmapApiKey) {
            this._gmapApiKey = await this.orm.call("traktop", "get_google_map_api_key", []);
        }
        return this._gmapApiKey;
    }
}

export const addressMultipleMarkersGmap = {
    component: AddressMultipleMarkersGmap,
};
registry.category("fields").add("address_multiple_markers_gmap", addressMultipleMarkersGmap);
